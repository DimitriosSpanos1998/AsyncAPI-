"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeEmptyObjects = exports.sortObjectKeys = exports.getValueByPath = exports.getValueByRef = exports.isRemoteRef = exports.isRefObject = exports.createRefPath = exports.createRefObject = exports.isPlainObject = exports.dotsToSlashes = exports.objectToSchema = exports.serializeInput = void 0;
const js_yaml_1 = require("js-yaml");
function serializeInput(document) {
    let triedConvertToYaml = false;
    try {
        if (typeof document === 'object') {
            return {
                format: 'json',
                document: JSON.parse(JSON.stringify(document)), // copy object
            };
        }
        const maybeJSON = JSON.parse(document);
        if (typeof maybeJSON === 'object') {
            if ('openapi' in maybeJSON) {
                return {
                    format: 'json',
                    document: maybeJSON,
                };
            }
            else {
                return {
                    format: 'json',
                    document: maybeJSON,
                };
            }
        }
        triedConvertToYaml = true; // NOSONAR
        // if `maybeJSON` is object, then we have 100% sure that we operate on JSON, 
        // but if it's `string` then we have option that it can be YAML but it doesn't have to be
        return {
            format: 'yaml',
            document: (0, js_yaml_1.load)(document),
        };
    }
    catch (e) {
        try {
            if (triedConvertToYaml) {
                throw e;
            }
            // try to parse (again) YAML, because the text itself may not have a JSON representation and cannot be represented as a JSON object/string
            return {
                format: 'yaml',
                document: (0, js_yaml_1.load)(document),
            };
        }
        catch (err) {
            throw new Error('AsyncAPI document must be a valid JSON or YAML document.');
        }
    }
}
exports.serializeInput = serializeInput;
function objectToSchema(obj) {
    return { type: 'object', properties: Object.assign({}, obj) };
}
exports.objectToSchema = objectToSchema;
function dotsToSlashes(topic) {
    return topic.replace(/\./g, '/');
}
exports.dotsToSlashes = dotsToSlashes;
function isPlainObject(value) {
    return Boolean(value && typeof value === 'object' && !Array.isArray(value));
}
exports.isPlainObject = isPlainObject;
function createRefObject(...paths) {
    return {
        $ref: createRefPath(...paths),
    };
}
exports.createRefObject = createRefObject;
function createRefPath(...paths) {
    return `#/${paths.map(String).map(tilde).join('/')}`;
}
exports.createRefPath = createRefPath;
function isRefObject(value) {
    return Boolean(value && '$ref' in value);
}
exports.isRefObject = isRefObject;
function isRemoteRef(value) {
    return isRefObject(value) && !value.$ref.startsWith('#');
}
exports.isRemoteRef = isRemoteRef;
function getValueByRef(root, ref) {
    if (!ref.startsWith('#')) {
        return;
    }
    // remove `#/` at start, split string by `/` and untilde (change ~1 to / etc)
    const path = ref.substring(2).split('/').map(untilde);
    return getValueByPath(root, path);
}
exports.getValueByRef = getValueByRef;
function getValueByPath(value, path) {
    let index = 0;
    const length = path.length;
    while (value != null && index < length) {
        value = value[path[index++]];
    }
    return index == length ? value : undefined;
}
exports.getValueByPath = getValueByPath;
function sortObjectKeys(obj, keys) {
    const newObject = {};
    // add sorted keys
    keys.forEach(key => {
        if (key in obj) {
            newObject[key] = obj[key];
        }
    });
    // add rest of keys
    Object.keys(obj).forEach(key => {
        if (!keys.includes(key)) {
            newObject[key] = obj[key];
        }
    });
    return newObject;
}
exports.sortObjectKeys = sortObjectKeys;
function tilde(str) {
    return str.replace(/[~/]{1}/g, (sub) => {
        switch (sub) {
            case '/': return '~1';
            case '~': return '~0';
        }
        return sub;
    });
}
function untilde(str) {
    if (!str.includes('~'))
        return str;
    return str.replace(/~[01]/g, (sub) => {
        switch (sub) {
            case '~1': return '/';
            case '~0': return '~';
        }
        return sub;
    });
}
function removeEmptyObjects(obj) {
    Object.keys(obj).forEach(key => {
        if (obj[key] && typeof obj[key] === 'object') {
            removeEmptyObjects(obj[key]);
            if (Object.keys(obj[key]).length === 0) {
                delete obj[key];
            }
        }
        else if (obj[key] === undefined) {
            delete obj[key];
        }
    });
    return obj;
}
exports.removeEmptyObjects = removeEmptyObjects;
