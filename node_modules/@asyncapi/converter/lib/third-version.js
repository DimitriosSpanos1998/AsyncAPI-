"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.converters = void 0;
const utils_1 = require("./utils");
exports.converters = {
    '3.0.0': from__2_6_0__to__3_0_0,
};
function from__2_6_0__to__3_0_0(asyncapi, options) {
    var _a;
    asyncapi.asyncapi = '3.0.0';
    const v2tov3Options = Object.assign({ pointOfView: 'application', useChannelIdExtension: true, convertServerComponents: true, convertChannelComponents: true, failOnParameterReference: false }, ((_a = options.v2tov3) !== null && _a !== void 0 ? _a : {}));
    v2tov3Options.idGenerator = v2tov3Options.idGenerator || idGeneratorFactory(v2tov3Options);
    const context = {
        refs: new Map(),
    };
    convertInfoObject(asyncapi, context);
    if ((0, utils_1.isPlainObject)(asyncapi.servers)) {
        asyncapi.servers = convertServerObjects(asyncapi.servers, asyncapi);
    }
    if ((0, utils_1.isPlainObject)(asyncapi.channels)) {
        asyncapi.channels = convertChannelObjects(asyncapi.channels, asyncapi, v2tov3Options, context);
    }
    convertComponents(asyncapi, v2tov3Options, context);
    replaceDeepRefs(asyncapi, context.refs, '', asyncapi);
    return (0, utils_1.sortObjectKeys)(asyncapi, ['asyncapi', 'id', 'info', 'defaultContentType', 'servers', 'channels', 'operations', 'components']);
}
/**
 * Moving Tags and ExternalDocs to the Info Object.
 */
function convertInfoObject(asyncapi, context) {
    if (asyncapi.tags) {
        asyncapi.info.tags = asyncapi.tags;
        context.refs.set((0, utils_1.createRefPath)('tags'), (0, utils_1.createRefPath)('info', 'tags'));
        delete asyncapi.tags;
    }
    if (asyncapi.externalDocs) {
        asyncapi.info.externalDocs = asyncapi.externalDocs;
        context.refs.set((0, utils_1.createRefPath)('externalDocs'), (0, utils_1.createRefPath)('info', 'externalDocs'));
        delete asyncapi.externalDocs;
    }
    asyncapi.info = (0, utils_1.sortObjectKeys)(asyncapi.info, ['title', 'version', 'description', 'termsOfService', 'contact', 'license', 'tags', 'externalDocs']);
}
/**
 * Split `url` field to the `host` and `pathname` (optional) fields.
 * Unify referencing mechanism in security field.
 */
function convertServerObjects(servers, asyncapi) {
    const newServers = {};
    Object.entries(servers).forEach(([serverName, server]) => {
        if ((0, utils_1.isRefObject)(server)) {
            newServers[serverName] = server;
            return;
        }
        const { host, pathname, protocol } = resolveServerUrl(server.url);
        server.host = host;
        if (pathname !== undefined) {
            server.pathname = pathname;
        }
        // Dont overwrite anything
        if (protocol !== undefined && server.protocol === undefined) {
            server.protocol = protocol;
        }
        delete server.url;
        if (server.security) {
            server.security = convertSecurityObject(server.security, asyncapi);
        }
        newServers[serverName] = (0, utils_1.sortObjectKeys)(server, ['host', 'pathname', 'protocol', 'protocolVersion', 'title', 'summary', 'description', 'variables', 'security', 'tags', 'externalDocs', 'bindings']);
    });
    return newServers;
}
/**
 * Convert operation part of channels into standalone operations
 */
function toStandaloneOperation(data) {
    const { kind, channel, asyncapi, operations, context, inComponents, channelId, channelAddress, options, oldPath } = data;
    let operation = channel[kind];
    const operationPath = inComponents ? ['components', 'operations'] : ['operations'];
    if ((0, utils_1.isPlainObject)(operation)) {
        const { operationId, operation: newOperation, messages } = convertOperationObject({ asyncapi, kind, channel, channelId, oldChannelId: channelAddress, operation, inComponents }, options, context);
        if (operation.security) {
            newOperation.security = convertSecurityObject(operation.security, asyncapi);
        }
        operationPath.push(operationId);
        context.refs.set((0, utils_1.createRefPath)(...oldPath, kind), (0, utils_1.createRefPath)(...operationPath));
        operations[operationId] = newOperation;
        delete channel[kind];
        return messages !== null && messages !== void 0 ? messages : {};
    }
    return {};
}
/**
 * Split Channel Objects to the Channel Objects and Operation Objects.
 */
function convertChannelObjects(channels, asyncapi, options, context, inComponents = false) {
    const newChannels = {};
    Object.entries(channels).forEach(([channelAddress, channel]) => {
        const oldPath = inComponents ? ['components', 'channels', channelAddress] : ['channels', channelAddress];
        const channelId = options.idGenerator({ asyncapi, kind: 'channel', key: channelAddress, path: oldPath, object: channel });
        const newPath = inComponents ? ['components', 'channels', channelId] : ['channels', channelId];
        context.refs.set((0, utils_1.createRefPath)(...oldPath), (0, utils_1.createRefPath)(...newPath));
        if ((0, utils_1.isRefObject)(channel)) {
            newChannels[channelId] = channel;
            return;
        }
        // assign address
        channel.address = channelAddress;
        // change the Server names to the Refs
        const servers = channel.servers;
        if (Array.isArray(servers)) {
            channel.servers = servers.map((serverName) => (0, utils_1.createRefObject)('servers', serverName));
        }
        //Change parameter formats
        if ((0, utils_1.isPlainObject)(channel.parameters)) {
            channel.parameters = convertParameters(channel.parameters);
        }
        const operations = {};
        // serialize publish and subscribe Operation Objects to standalone object
        const publishMessages = toStandaloneOperation({ kind: 'publish', channel, asyncapi, operations, context, inComponents, channelId, channelAddress, options, oldPath });
        const subscribeMessages = toStandaloneOperation({ kind: 'subscribe', channel, asyncapi, operations, context, inComponents, channelId, channelAddress, options, oldPath });
        if (publishMessages || subscribeMessages) {
            const allOperationMessages = Object.assign(Object.assign({}, publishMessages), subscribeMessages);
            channel.messages = convertMessages({
                messages: allOperationMessages
            });
        }
        setOperationsOnRoot({ operations, inComponents, asyncapi, oldPath });
        newChannels[channelId] = (0, utils_1.sortObjectKeys)(channel, ['address', 'messages', 'title', 'summary', 'description', 'servers', 'parameters', 'tags', 'externalDocs', 'bindings']);
    });
    return newChannels;
}
/**
 * Assign the operations to the root AsyncAPI object.
 */
function setOperationsOnRoot(data) {
    var _a, _b, _c, _d, _e;
    const { operations, inComponents, asyncapi, oldPath } = data;
    if (Object.keys(operations)) {
        if (inComponents) {
            const components = asyncapi.components = (_a = asyncapi.components) !== null && _a !== void 0 ? _a : {};
            components.operations = Object.assign(Object.assign({}, (_b = components.operations) !== null && _b !== void 0 ? _b : {}), operations);
            // if given component is used in the `channels` object then create references for operations in the `operations` object
            if (channelIsUsed((_c = asyncapi.channels) !== null && _c !== void 0 ? _c : {}, oldPath)) {
                const referencedOperations = Object.keys(operations).reduce((acc, current) => {
                    acc[current] = (0, utils_1.createRefObject)('components', 'operations', current);
                    return acc;
                }, {});
                asyncapi.operations = Object.assign(Object.assign({}, (_d = asyncapi.operations) !== null && _d !== void 0 ? _d : {}), referencedOperations);
            }
        }
        else {
            asyncapi.operations = Object.assign(Object.assign({}, (_e = asyncapi.operations) !== null && _e !== void 0 ? _e : {}), operations);
        }
    }
}
/**
 * Points to the connected channel and split messages for channel
 */
function convertOperationObject(data, options, context) {
    const { asyncapi, channelId, oldChannelId, kind, inComponents } = data;
    const operation = Object.assign({}, data.operation);
    const oldChannelPath = ['channels', oldChannelId];
    if (inComponents) {
        oldChannelPath.unshift('components');
    }
    const newChannelPath = ['channels', channelId];
    if (inComponents) {
        newChannelPath.unshift('components');
    }
    const operationId = options.idGenerator({ asyncapi, kind: 'operation', key: kind, path: oldChannelPath, object: data.operation, parentId: channelId });
    operation.channel = (0, utils_1.createRefObject)(...newChannelPath);
    try {
        delete operation.operationId;
    }
    catch (err) { }
    const isPublish = kind === 'publish';
    if (options.pointOfView === 'application') {
        operation.action = isPublish ? 'receive' : 'send';
    }
    else {
        operation.action = isPublish ? 'send' : 'receive';
    }
    const message = operation.message;
    let serializedMessages = {};
    if (message) {
        delete operation.message;
        const oldMessagePath = ['channels', oldChannelId, kind, 'message'];
        const newMessagePath = ['channels', channelId, 'messages'];
        if (inComponents) {
            oldMessagePath.unshift('components');
            newMessagePath.unshift('components');
        }
        serializedMessages = moveMessagesFromOperation(message, newMessagePath, oldMessagePath, asyncapi, options, context, operationId);
        applyMessageRefsToOperation(serializedMessages, newMessagePath, operation);
    }
    const sortedOperation = (0, utils_1.sortObjectKeys)(operation, ['action', 'channel', 'title', 'summary', 'description', 'security', 'tags', 'externalDocs', 'bindings', 'traits']);
    return { operationId, operation: sortedOperation, messages: serializedMessages };
}
/**
 * Remove all messages under operations and return an object of them.
 */
function moveMessagesFromOperation(message, newMessagePath, oldMessagePath, asyncapi, options, context, operationId) {
    if (Array.isArray(message.oneOf)) {
        //Message oneOf no longer exists, it's implicit by having multiple entires in the message object.
        return message.oneOf.reduce((acc, current, index) => {
            const messagePath = [...oldMessagePath, 'oneOf', index];
            const messageId = options.idGenerator({ asyncapi, kind: 'message', key: index, path: messagePath, object: current, parentId: operationId });
            context.refs.set((0, utils_1.createRefPath)(...messagePath), (0, utils_1.createRefPath)(...newMessagePath, messageId));
            acc[messageId] = current;
            return acc;
        }, {});
    }
    else {
        const messageId = options.idGenerator({ asyncapi, kind: 'message', key: 'message', path: oldMessagePath, object: message, parentId: operationId });
        context.refs.set((0, utils_1.createRefPath)(...oldMessagePath), (0, utils_1.createRefPath)(...newMessagePath, messageId));
        return { [messageId]: message };
    }
}
/**
 * Add references of messages to operations.
 */
function applyMessageRefsToOperation(serializedMessages, newMessagePath, operation) {
    if (Object.keys(serializedMessages !== null && serializedMessages !== void 0 ? serializedMessages : {}).length > 0) {
        const newOperationMessages = [];
        Object.entries(serializedMessages).forEach(([messageId, messageValue]) => {
            if ((0, utils_1.isRemoteRef)(messageValue)) {
                // shallow copy of JS reference
                newOperationMessages.push(Object.assign({}, messageValue));
            }
            else {
                const messagePath = [...newMessagePath, messageId];
                newOperationMessages.push((0, utils_1.createRefObject)(...messagePath));
            }
        });
        operation.messages = newOperationMessages;
    }
}
/**
 * Convert messages that use custom schema format into schema union.
 */
function convertMessages(data) {
    const messages = Object.assign({}, data.messages);
    // Convert schema formats to union schemas
    Object.entries(messages).forEach(([_, message]) => {
        delete message.messageId;
        if (message.schemaFormat !== undefined) {
            const payloadSchema = message.payload;
            message.payload = {
                schemaFormat: message.schemaFormat,
                schema: payloadSchema
            };
            delete message.schemaFormat;
        }
    });
    return messages;
}
/**
 * Convert `channels`, `servers` and `securitySchemes` in components.
 */
function convertComponents(asyncapi, options, context) {
    const components = asyncapi.components;
    if (!(0, utils_1.isPlainObject)(components)) {
        return;
    }
    if (options.convertServerComponents && (0, utils_1.isPlainObject)(components.servers)) {
        components.servers = convertServerObjects(components.servers, asyncapi);
    }
    if (options.convertChannelComponents && (0, utils_1.isPlainObject)(components.channels)) {
        components.channels = convertChannelObjects(components.channels, asyncapi, options, context, true);
    }
    if ((0, utils_1.isPlainObject)(components.securitySchemes)) {
        components.securitySchemes = convertSecuritySchemes(components.securitySchemes);
    }
    if ((0, utils_1.isPlainObject)(components.messages)) {
        components.messages = convertMessages({
            messages: components.messages
        });
    }
    if ((0, utils_1.isPlainObject)(components.parameters)) {
        components.parameters = convertParameters(components.parameters);
    }
}
/**
 * Convert all parameters to the new v3 format
 */
function convertParameters(parameters) {
    const newParameters = {};
    Object.entries(parameters).forEach(([name, parameter]) => {
        newParameters[name] = convertParameter(parameter);
    });
    return newParameters;
}
/**
 * Convert the old v2 parameter object to v3.
 *
 * Ensure that extensions and references are all kept as is.
 *
 * Does not include extensions from schema.
 */
function convertParameter(parameter) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
    const ref = (_a = parameter['$ref']) !== null && _a !== void 0 ? _a : null;
    if (ref !== null) {
        return {
            $ref: ref
        };
    }
    if ((_b = parameter.schema) === null || _b === void 0 ? void 0 : _b.$ref) {
        console.warn('Could not convert parameter object because the `.schema` property was a reference.\nThis have to be changed manually if you want any of the properties included. For now your parameter is an empty object after conversion. The reference was ' + ((_c = parameter.schema) === null || _c === void 0 ? void 0 : _c.$ref));
    }
    const enumValues = (_e = (_d = parameter.schema) === null || _d === void 0 ? void 0 : _d.enum) !== null && _e !== void 0 ? _e : null;
    const constValue = (_g = (_f = parameter.schema) === null || _f === void 0 ? void 0 : _f.const) !== null && _g !== void 0 ? _g : null;
    const defaultValues = (_j = (_h = parameter.schema) === null || _h === void 0 ? void 0 : _h.default) !== null && _j !== void 0 ? _j : null;
    const description = (_m = (_k = parameter.description) !== null && _k !== void 0 ? _k : (_l = parameter.schema) === null || _l === void 0 ? void 0 : _l.description) !== null && _m !== void 0 ? _m : null;
    const examples = (_p = (_o = parameter.schema) === null || _o === void 0 ? void 0 : _o.examples) !== null && _p !== void 0 ? _p : null;
    const location = (_q = parameter.location) !== null && _q !== void 0 ? _q : null;
    reportUnsupportedParameterValues(parameter.schema);
    //Make sure we keep parameter extensions
    const v2ParameterObjectProperties = ["location", "schema", "description"];
    const v2ParameterObjectExtensions = Object.entries(parameter).filter(([key,]) => {
        return !v2ParameterObjectProperties.includes(key);
    });
    //Return the new v3 parameter object
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, v2ParameterObjectExtensions), (enumValues === null ? null : { enum: enumValues })), (constValue === null ? null : { enum: [constValue] })), (defaultValues === null ? null : { default: defaultValues })), (description === null ? null : { description })), (examples === null ? null : { examples })), (location === null ? null : { location }));
}
/**
 * This function makes sure we complain if a parameter schema uses now unsupported properties
 */
function reportUnsupportedParameterValues(schema) {
    if (schema === undefined)
        return;
    const excessProperties = Object.entries(schema).filter((([propertyName,]) => {
        return !['$ref', 'enum', 'const', 'default', 'examples', 'description'].includes(propertyName);
    }));
    if (excessProperties.length > 0) {
        const listOfProperties = excessProperties.map(([propertyName, property]) => {
            return `- schema.${propertyName} with value: ${JSON.stringify(property)} are no longer supported`;
        });
        console.warn(`Found properties in parameter schema that are no longer supported. Conversion completes with empty parameter object.\n${listOfProperties.join('\n')}`);
    }
}
/**
 * Convert `channels`, `servers` and `securitySchemes` in components.
 */
function convertSecuritySchemes(securitySchemes) {
    const newSecuritySchemes = {};
    Object.entries(securitySchemes).forEach(([name, scheme]) => {
        newSecuritySchemes[name] = convertSecuritySchemeObject(scheme);
    });
    return newSecuritySchemes;
}
/**
 * Unify referencing mechanism in security field
 */
function convertSecurityObject(security, asyncapi) {
    const newSecurity = [];
    security.forEach(securityItem => {
        Object.entries(securityItem).forEach(([securityName, scopes]) => {
            // without scopes - use ref
            if (!scopes.length) {
                newSecurity.push((0, utils_1.createRefObject)('components', 'securitySchemes', securityName));
                return;
            }
            // create new security scheme in the components/securitySchemes with appropriate scopes
            const securityScheme = (0, utils_1.getValueByPath)(asyncapi, ['components', 'securitySchemes', securityName]);
            // handle logic only on `oauth2` and `openIdConnect` security mechanism
            if (securityScheme.type === 'oauth2' || securityScheme.type === 'openIdConnect') {
                const newSecurityScheme = convertSecuritySchemeObject(securityScheme);
                newSecurity.push(Object.assign(Object.assign({}, newSecurityScheme), { scopes: [...scopes] }));
            }
        });
    });
    return newSecurity;
}
const flowKinds = ['implicit', 'password', 'clientCredentials', 'authorizationCode'];
/**
 * Convert security scheme object to new from v3 version (flow.[x].scopes -> flow.[x].availableScopes).
 */
function convertSecuritySchemeObject(original) {
    const securityScheme = JSON.parse(JSON.stringify(original));
    if (securityScheme.flows) {
        flowKinds.forEach(flow => {
            const flowScheme = securityScheme.flows[flow];
            if (flowScheme === null || flowScheme === void 0 ? void 0 : flowScheme.scopes) {
                flowScheme.availableScopes = flowScheme.scopes;
                delete flowScheme.scopes;
            }
        });
    }
    return securityScheme;
}
/**
 * Split `url` to the `host` and `pathname` (optional) fields.
 *
 * This function takes care of https://github.com/asyncapi/spec/pull/888
 */
function resolveServerUrl(url) {
    let [maybeProtocol, maybeHost] = url.split('://');
    if (!maybeHost) {
        maybeHost = maybeProtocol;
    }
    const [host, ...pathnames] = maybeHost.split('/');
    if (pathnames.length) {
        return { host, pathname: `/${pathnames.join('/')}`, protocol: maybeProtocol };
    }
    return { host, pathname: undefined, protocol: maybeProtocol };
}
/**
 * Check if given channel (based on path) is used in the `channels` object.
 */
function channelIsUsed(channels, path) {
    for (const channel of Object.values(channels)) {
        if ((0, utils_1.isRefObject)(channel) && (0, utils_1.createRefPath)(...path) === channel.$ref) {
            return true;
        }
    }
    return false;
}
/**
 * Replace all deep local references with the new beginning of ref (when object is moved to another place).
 */
function replaceDeepRefs(value, refs, key, parent) {
    if (key === '$ref' && typeof value === 'string') {
        const newRef = replaceRef(value, refs);
        if (typeof newRef === 'string') {
            parent[key] = newRef;
        }
        return;
    }
    if (Array.isArray(value)) {
        return value.forEach((item, idx) => replaceDeepRefs(item, refs, idx, value));
    }
    if (value && typeof value === 'object') {
        for (const objKey in value) {
            replaceDeepRefs(value[objKey], refs, objKey, value);
        }
    }
}
function replaceRef(ref, refs) {
    const allowed = [];
    refs.forEach((_, key) => {
        // few refs can be allowed
        if (ref.startsWith(key)) {
            allowed.push(key);
        }
    });
    // find the longest one
    allowed.sort((a, b) => a.length - b.length);
    const from = allowed.pop();
    if (!from) {
        return;
    }
    const toReplace = refs.get(from);
    if (toReplace) {
        return ref.replace(from, toReplace);
    }
}
/**
 * Default function to generate ids for objects.
 */
function idGeneratorFactory(options) {
    const useChannelIdExtension = options.useChannelIdExtension;
    return (data) => {
        const { asyncapi, kind, object, key, parentId } = data;
        switch (kind) {
            case 'channel':
                return generateIdForChannel(object, key, useChannelIdExtension);
            case 'operation':
                {
                    const oldOperationId = object.operationId;
                    const operationId = oldOperationId || (parentId ? `${parentId}.${key}` : kind);
                    return operationId;
                }
                ;
            case 'message':
                return generateIdForMessage(object, asyncapi, parentId, key);
            default: return '';
        }
    };
}
function generateIdForChannel(object, key, useChannelIdExtension) {
    if ((0, utils_1.isRefObject)(object)) {
        const id = key;
        return id;
    }
    const channel = object;
    let channelId;
    if (useChannelIdExtension) {
        channelId = channel['x-channelId'] || key;
    }
    else {
        channelId = key;
    }
    return channelId;
}
function generateIdForMessage(object, asyncapi, parentId, key) {
    if ((0, utils_1.isRefObject)(object)) {
        const possibleMessage = (0, utils_1.getValueByRef)(asyncapi, object.$ref);
        if (possibleMessage === null || possibleMessage === void 0 ? void 0 : possibleMessage.messageId) {
            const messageId = possibleMessage.messageId;
            return messageId;
        }
    }
    const messageId = object.messageId;
    if (messageId) {
        return messageId;
    }
    let operationKind;
    const splitParentId = parentId.split('.');
    if (splitParentId.length === 1) {
        operationKind = parentId;
    }
    else {
        operationKind = splitParentId.pop();
    }
    if (typeof key === 'number') {
        return `${operationKind}.message.${key}`;
    }
    return `${operationKind}.message`;
}
