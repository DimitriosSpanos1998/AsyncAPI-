"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.from_openapi_to_asyncapi = exports.converters = void 0;
const utils_1 = require("./utils");
exports.converters = {
    '3.0.0': from_openapi_to_asyncapi,
};
/**
 * Converts an OpenAPI document to an AsyncAPI document.
 * @param {OpenAPIDocument} openapi - The OpenAPI document to convert.
 * @param {ConvertOptions} options - Conversion options.
 * @returns {AsyncAPIDocument} The converted AsyncAPI document.
 */
function from_openapi_to_asyncapi(openapi, options = {}) {
    const perspective = options.perspective || 'server';
    const asyncapi = {
        asyncapi: '3.0.0',
        info: convertInfoObject(openapi.info, openapi),
        servers: openapi.servers ? convertServerObjects(openapi.servers, openapi) : undefined,
        channels: {},
        operations: {},
        components: convertComponents(openapi)
    };
    const { channels, operations } = convertPaths(openapi.paths, perspective);
    asyncapi.channels = channels;
    asyncapi.operations = operations;
    (0, utils_1.removeEmptyObjects)(asyncapi);
    return (0, utils_1.sortObjectKeys)(asyncapi, ['asyncapi', 'info', 'defaultContentType', 'servers', 'channels', 'operations', 'components']);
}
exports.from_openapi_to_asyncapi = from_openapi_to_asyncapi;
/**
 * Converts openAPI info objects to asyncAPI info objects.
 * @param info - The openAPI info object to convert.
 * @param openapi - The complete openAPI document.
 * @returns openAPI info object
 */
function convertInfoObject(info, openapi) {
    return (0, utils_1.sortObjectKeys)(Object.assign(Object.assign({}, info), { tags: [openapi.tags], externalDocs: openapi.externalDocs }), [
        "title",
        "version",
        "description",
        "termsOfService",
        "contact",
        "license",
        "tags",
        "externalDocs",
    ]);
}
/**
 * Converts OpenAPI server objects to AsyncAPI server objects.
 * @param {ServerObject[]} servers - The OpenAPI server objects to convert.
 * @param {OpenAPIDocument} openapi - The complete OpenAPI document.
 * @returns {AsyncAPIDocument['servers']} The converted AsyncAPI server objects.
 */
function convertServerObjects(servers, openapi) {
    const newServers = {};
    const security = openapi.security;
    servers.forEach((server) => {
        const serverName = generateServerName(server.url);
        if ((0, utils_1.isRefObject)(server)) {
            newServers[serverName] = server;
            return;
        }
        const { host, pathname, protocol } = resolveServerUrl(server.url);
        server.host = host;
        if (pathname !== undefined) {
            server.pathname = pathname;
        }
        if (protocol !== undefined && server.protocol === undefined) {
            server.protocol = protocol;
        }
        delete server.url;
        if (security) {
            server.security = security.map((securityRequirement) => {
                // pass through the security requirement, conversion will happen in components
                return securityRequirement;
            });
            delete openapi.security;
        }
        newServers[serverName] = (0, utils_1.sortObjectKeys)(server, ['host', 'pathname', 'protocol', 'protocolVersion', 'title', 'summary', 'description', 'variables', 'security', 'tags', 'externalDocs', 'bindings']);
    });
    return newServers;
}
/**
 * Generates a server name based on the server URL.
 * @param {string} url - The server URL.
 * @returns {string} The generated server name.
 */
function generateServerName(url) {
    const { host, pathname } = resolveServerUrl(url);
    const baseName = host.split('.').slice(-2).join('.');
    const pathSegment = pathname ? pathname.split('/')[1] : '';
    return `${baseName}${pathSegment ? `_${pathSegment}` : ''}`.replace(/[^a-zA-Z0-9_]/g, '_');
}
function resolveServerUrl(url) {
    let [maybeProtocol, maybeHost] = url.split("://");
    if (!maybeHost) {
        maybeHost = maybeProtocol;
    }
    const [host, ...pathnames] = maybeHost.split("/");
    if (pathnames.length) {
        return {
            host,
            pathname: `/${pathnames.join("/")}`,
            protocol: maybeProtocol,
        };
    }
    return { host, pathname: undefined, protocol: maybeProtocol };
}
/**
 * Converts OpenAPI paths to AsyncAPI channels and operations.
 * @param {Record<string, any>} paths - The OpenAPI paths object.
 * @param {'client' | 'server'} perspective - The perspective of the conversion (client or server).
 * @returns {{ channels: AsyncAPIDocument['channels'], operations: AsyncAPIDocument['operations'] }}
 */
function convertPaths(paths, perspective) {
    var _a;
    const channels = {};
    const operations = {};
    if (paths) {
        for (const [path, pathItemOrRef] of Object.entries(paths)) {
            if (!(0, utils_1.isPlainObject)(pathItemOrRef))
                continue;
            const pathItem = (0, utils_1.isRefObject)(pathItemOrRef) ? pathItemOrRef : pathItemOrRef;
            const channelName = path.replace(/^\//, '').replace(/\//g, '_') || 'root';
            channels[channelName] = {
                address: path,
                messages: {},
                parameters: convertPathParameters(path, pathItem.parameters)
            };
            for (const [method, operation] of Object.entries(pathItem)) {
                if (['get', 'post', 'put', 'delete', 'patch', 'options', 'head', 'trace'].includes(method) && (0, utils_1.isPlainObject)(operation)) {
                    const operationObject = operation;
                    const operationId = operationObject.operationId || `${method}${channelName}`;
                    // Create operation
                    operations[operationId] = {
                        action: perspective === 'client' ? 'send' : 'receive',
                        channel: (0, utils_1.createRefObject)('channels', channelName),
                        summary: operationObject.summary,
                        description: operationObject.description,
                        tags: (_a = operationObject.tags) === null || _a === void 0 ? void 0 : _a.map((tag) => ({ name: tag })),
                        bindings: {
                            http: {
                                method: method.toUpperCase(),
                            }
                        },
                        messages: []
                    };
                    // Convert request body to message
                    if (operationObject.requestBody) {
                        const requestMessages = convertRequestBodyToMessages(operationObject.requestBody, operationId, method);
                        Object.assign(channels[channelName].messages, requestMessages);
                        operations[operationId].messages.push(...Object.keys(requestMessages).map(msgName => (0, utils_1.createRefObject)('channels', channelName, 'messages', msgName)));
                    }
                    // Convert responses to messages
                    if (operationObject.responses) {
                        const responseMessages = convertResponsesToMessages(operationObject.responses, operationId, method);
                        Object.assign(channels[channelName].messages, responseMessages);
                        operations[operationId].reply = {
                            channel: (0, utils_1.createRefObject)('channels', channelName),
                            messages: Object.keys(responseMessages).map(msgName => (0, utils_1.createRefObject)('channels', channelName, 'messages', msgName))
                        };
                    }
                    // Add reply section if there are responses
                    if (operationObject.responses && Object.keys(operationObject.responses).length > 0) {
                        operations[operationId].reply = {
                            channel: (0, utils_1.createRefObject)('channels', channelName),
                            messages: Object.entries(operationObject.responses).map(([statusCode, response]) => (0, utils_1.createRefObject)('channels', channelName, 'messages', `${operationId}Response${statusCode}`))
                        };
                    }
                    // Convert parameters
                    if (operationObject.parameters) {
                        const params = convertOperationParameters(operationObject.parameters);
                        if (Object.keys(params).length > 0) {
                            channels[channelName].parameters = Object.assign(Object.assign({}, channels[channelName].parameters), params);
                        }
                    }
                }
            }
            (0, utils_1.removeEmptyObjects)(channels[channelName]);
        }
    }
    return { channels, operations };
}
/**
 * Converts OpenAPI path parameters to AsyncAPI channel parameters.
 * @param {any[]} parameters - The OpenAPI path parameters.
 * @returns {Record<string, any>} The converted AsyncAPI channel parameters.
 */
function convertPathParameters(path, parameters = []) {
    var _a;
    const convertedParams = {};
    const paramNames = ((_a = path.match(/\{([^}]+)\}/g)) === null || _a === void 0 ? void 0 : _a.map(param => param.slice(1, -1))) || [];
    paramNames.forEach(paramName => {
        const param = parameters.find(p => p.name === paramName && p.in === 'path');
        if (param) {
            convertedParams[paramName] = convertParameter(param);
        }
        else {
            // If the parameter is not defined in the OpenAPI spec, create a default one
            convertedParams[paramName] = {
                description: `Path parameter ${paramName}`,
            };
        }
    });
    return convertedParams;
}
/**
 * Converts OpenAPI operatiion parameters to AsyncAPI operation parameters.
 * @param {any[]} parameters - The OpenAPI operation parameters.
 * @returns {Record<string, any>} The converted AsyncAPI operation parameters.
 */
function convertOperationParameters(parameters) {
    const convertedParams = {};
    parameters.forEach(param => {
        if (!(0, utils_1.isRefObject)(param) && param.in === 'query') {
            convertedParams[param.name] = convertParameter(param);
        }
    });
    return convertedParams;
}
/**
 * Converts an OpenAPI Parameter Object to an AsyncAPI Parameter Object.
 * @param {ParameterObject} param - The OpenAPI Parameter Object.
 * @returns {any} The converted AsyncAPI Parameter Object.
 */
function convertParameter(param) {
    const convertedParam = {
        description: param.description,
    };
    if (param.required) {
        convertedParam.required = param.required;
    }
    if (param.schema && !(0, utils_1.isRefObject)(param.schema)) {
        if (param.schema.enum) {
            convertedParam.enum = param.schema.enum;
        }
        if (param.schema.default !== undefined) {
            convertedParam.default = param.schema.default;
        }
    }
    if (param.examples) {
        convertedParam.examples = Object.values(param.examples).map((example) => (0, utils_1.isRefObject)(example) ? example : example.value);
    }
    // the location based on the parameter's 'in' property
    switch (param.in) {
        case 'query':
        case 'header':
        case 'cookie':
            convertedParam.location = `$message.header#/${param.name}`;
            break;
        case 'path':
            // Path parameters are part of the channel address
            break;
        default:
            // If 'in' is not recognized, default to payload
            convertedParam.location = `$message.payload#/${param.name}`;
    }
    return convertedParam;
}
function convertRequestBodyToMessages(requestBody, operationId, method) {
    const messages = {};
    if ((0, utils_1.isPlainObject)(requestBody.content)) {
        Object.entries(requestBody.content).forEach(([contentType, mediaType]) => {
            const messageName = `${operationId}Request`;
            messages[messageName] = {
                name: messageName,
                title: `${method.toUpperCase()} request`,
                contentType: contentType,
                payload: convertSchema(mediaType.schema),
                summary: requestBody.description,
            };
        });
    }
    return messages;
}
/**
 * Converts OpenAPI Response Objects to AsyncAPI Message Objects.
 * @param {ResponsesObject} responses - The OpenAPI Response Objects to convert.
 * @param {string} operationId - The ID of the operation these responses belong to.
 * @param {string} method - The HTTP method of the operation.
 * @returns {Record<string, any>} A record of converted AsyncAPI Message Objects.
 */
function convertResponsesToMessages(responses, operationId, method) {
    const messages = {};
    Object.entries(responses).forEach(([statusCode, response]) => {
        if ((0, utils_1.isPlainObject)(response.content)) {
            Object.entries(response.content).forEach(([contentType, mediaType]) => {
                const messageName = `${operationId}Response${statusCode}`;
                messages[messageName] = {
                    name: messageName,
                    title: `${method.toUpperCase()} response ${statusCode}`,
                    contentType: contentType,
                    payload: convertSchema(mediaType.schema),
                    summary: response.description,
                    headers: response.headers ? convertHeadersToSchema(response.headers) : undefined,
                };
            });
        }
        else {
            const messageName = `${operationId}Response${statusCode}`;
            messages[messageName] = {
                name: messageName,
                title: `${method.toUpperCase()} response ${statusCode}`,
                summary: response.description,
            };
        }
    });
    return messages;
}
/**
 * Converts OpenAPI Components Object to AsyncAPI Components Object.
 * @param {OpenAPIDocument} openapi - The complete OpenAPI document.
 * @returns {AsyncAPIDocument['components']} The converted AsyncAPI Components Object.
 */
function convertComponents(openapi) {
    const asyncComponents = {};
    if (openapi.components) {
        if (openapi.components.schemas) {
            asyncComponents.schemas = convertSchemas(openapi.components.schemas);
        }
        if (openapi.components.securitySchemes) {
            asyncComponents.securitySchemes = convertSecuritySchemes(openapi.components.securitySchemes);
        }
        if (openapi.components.parameters) {
            asyncComponents.parameters = {};
            for (const [name, param] of Object.entries(openapi.components.parameters)) {
                if (!(0, utils_1.isRefObject)(param)) {
                    asyncComponents.parameters[name] = convertParameter(param);
                }
                else {
                    asyncComponents.parameters[name] = param;
                }
            }
        }
        if (openapi.components.responses) {
            asyncComponents.messages = convertComponentResponsesToMessages(openapi.components.responses);
        }
        if (openapi.components.requestBodies) {
            asyncComponents.messageTraits = convertRequestBodiesToMessageTraits(openapi.components.requestBodies);
        }
        if (openapi.components.headers) {
            asyncComponents.messageTraits = Object.assign(Object.assign({}, (asyncComponents.messageTraits || {})), convertHeadersToMessageTraits(openapi.components.headers));
        }
        if (openapi.components.examples) {
            asyncComponents.examples = openapi.components.examples;
        }
    }
    return (0, utils_1.removeEmptyObjects)(asyncComponents);
}
/**
 * converts openAPI schema object to multiformat/schema object
 * @param schema openAPI schema object
 * @returns multiformat/schema object
 */
function convertSchema(schema) {
    if ((0, utils_1.isRefObject)(schema)) {
        // Check if it's an external reference
        if (schema.$ref.startsWith('./') || schema.$ref.startsWith('http')) {
            // Convert external references to multi-format schema objects
            return {
                schemaFormat: 'application/vnd.oai.openapi;version=3.0.0',
                schema: schema
            };
        }
        return schema;
    }
    return {
        schemaFormat: 'application/vnd.oai.openapi;version=3.0.0',
        schema: schema
    };
}
/**
 * Converts OpenAPI Schema Objects to AsyncAPI Schema Objects.
 * @param {Record<string, any>} schemas - The OpenAPI Schema Objects to convert.
 * @returns {Record<string, any>} The converted AsyncAPI Schema Objects.
 */
function convertSchemas(schemas) {
    const convertedSchemas = {};
    for (const [name, schema] of Object.entries(schemas)) {
        convertedSchemas[name] = convertSchema(schema);
    }
    return convertedSchemas;
}
/**
 * Converts a single OpenAPI Security Scheme Object to an AsyncAPI Security Scheme Object.
 * @param {Record<string, any>} scheme - The OpenAPI Security Scheme Object to convert.
 * @returns {Record<string, any>} The converted AsyncAPI Security Scheme Object.
 */
function convertSecuritySchemes(securitySchemes) {
    const convertedSchemes = {};
    for (const [name, scheme] of Object.entries(securitySchemes)) {
        convertedSchemes[name] = convertSecurityScheme(scheme);
    }
    return convertedSchemes;
}
/**
 * Converts a single OpenAPI Security Scheme Object to an AsyncAPI Security Scheme Object.
 * @param {any} scheme - The OpenAPI Security Scheme Object to convert.
 * @returns {Record<string, any>} The converted AsyncAPI Security Scheme Object.
 */
function convertSecurityScheme(scheme) {
    const convertedScheme = {
        type: scheme.type,
        description: scheme.description
    };
    if (scheme.type === 'oauth2' && scheme.flows) {
        const newFlows = JSON.parse(JSON.stringify(scheme.flows));
        function convertScopesToAvailableScopes(obj) {
            for (const key in obj) {
                if (obj.hasOwnProperty(key)) {
                    if (key === 'scopes') {
                        obj['availableScopes'] = obj[key];
                        delete obj[key];
                    }
                    else if (typeof obj[key] === 'object') {
                        convertScopesToAvailableScopes(obj[key]);
                    }
                }
            }
        }
        convertScopesToAvailableScopes(newFlows);
        convertedScheme.flows = newFlows;
        if (scheme.scopes) {
            convertedScheme.scopes = Object.keys(scheme.scopes);
        }
    }
    else if (scheme.type === 'http') {
        convertedScheme.scheme = scheme.scheme;
        if (scheme.scheme === 'bearer') {
            convertedScheme.bearerFormat = scheme.bearerFormat;
        }
    }
    else if (scheme.type === 'apiKey') {
        convertedScheme.in = scheme.in;
        convertedScheme.name = scheme.name;
    }
    return convertedScheme;
}
/**
 * Converts OpenAPI Response Objects from the components section to AsyncAPI Message Objects.
 * @param {Record<string, any>} responses - The OpenAPI Response Objects to convert.
 * @returns {Record<string, any>} A record of converted AsyncAPI Message Objects.
 */
function convertComponentResponsesToMessages(responses) {
    const messages = {};
    for (const [name, response] of Object.entries(responses)) {
        if ((0, utils_1.isPlainObject)(response.content)) {
            Object.entries(response.content).forEach(([contentType, mediaType]) => {
                messages[name] = {
                    name: name,
                    contentType: contentType,
                    payload: convertSchema(mediaType.schema),
                    summary: response.description,
                    headers: response.headers ? convertHeadersToSchema(response.headers) : undefined,
                };
            });
        }
        else {
            messages[name] = {
                name: name,
                summary: response.description,
            };
        }
    }
    return messages;
}
/**
 * Converts OpenAPI Request Body Objects from the components section to AsyncAPI Message Trait Objects.
 * @param {Record<string, any>} requestBodies - The OpenAPI Request Body Objects to convert.
 * @returns {Record<string, any>} A record of converted AsyncAPI Message Trait Objects.
 */
function convertRequestBodiesToMessageTraits(requestBodies) {
    const messageTraits = {};
    for (const [name, requestBodyOrRef] of Object.entries(requestBodies)) {
        if (!(0, utils_1.isRefObject)(requestBodyOrRef) && requestBodyOrRef.content) {
            const contentType = Object.keys(requestBodyOrRef.content)[0];
            messageTraits[name] = {
                name: name,
                contentType: contentType,
                description: requestBodyOrRef.description,
            };
            if (requestBodyOrRef.content[contentType].schema &&
                requestBodyOrRef.content[contentType].schema.properties &&
                requestBodyOrRef.content[contentType].schema.properties.headers) {
                messageTraits[name].headers = requestBodyOrRef.content[contentType].schema.properties.headers;
            }
        }
    }
    return messageTraits;
}
/**
 * Converts OpenAPI Header Objects from the components section to AsyncAPI Message Trait Objects.
 * @param {Record<string, any>} headers - The OpenAPI Header Objects to convert.
 * @returns {Record<string, any>} A record of converted AsyncAPI Message Trait Objects.
 */
function convertHeadersToMessageTraits(headers) {
    const messageTraits = {};
    for (const [name, header] of Object.entries(headers)) {
        messageTraits[`Header${name}`] = {
            headers: {
                type: 'object',
                properties: {
                    [name]: header.schema,
                },
                required: [name],
            },
        };
    }
    return messageTraits;
}
/**
 * Converts OpenAPI Header Objects to an AsyncAPI Schema Object representing the headers.
 * @param {Record<string, any>} headers - The OpenAPI Header Objects to convert.
 * @returns {SchemaObject} An AsyncAPI Schema Object representing the headers.
 */
function convertHeadersToSchema(headers) {
    const properties = {};
    for (const [name, headerOrRef] of Object.entries(headers)) {
        if (!(0, utils_1.isRefObject)(headerOrRef)) {
            properties[name] = headerOrRef.schema || {};
        }
    }
    return {
        type: 'object',
        properties,
    };
}
